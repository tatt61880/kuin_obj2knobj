{
	Obj.kn v1.11 (for Kuin 1.01):
		Last Modified: 2014/02/21 18:36:28.
		Created by Tatt(@tatt61880)
		https://twitter.com/tatt61880
		https://github.com/tatt61880

	objファイルを扱うライブラリです。
}

func Load(path: []char): @CObj
	return (#@CObj).Load(path)
end func

class CObj()
	var v: []cVector
	var uv: []cVector2D
	var vn: []cVector
	var f: []@CFacet
	func Load(path: []char): @CObj
		var stream: File@CLoadStream :: File@LoadFileStream(path)
		if(stream =& null)
			return null
		end if
		do me.v  :: [(#cVector).Init(0.0, 0.0, 0.0)]
		do me.uv :: [(#cVector2D).Init(0.0, 0.0)]
		do me.vn :: [(#cVector).Init(0.0, 0.0, 0.0)]
		do me.f :: #[0]@CFacet
		const n: int :: 3 {三角形限定}
		var posIdSet: []@CPosIdSet :: #[n]@CPosIdSet
		foreach p(posIdSet)
			do p :: #@CPosIdSet
		end foreach
		var str: []char
		var p1: int :: 0
		var p2: int :: 0

		do stream.SetSplitChars(" \n")
		try
			while a()
				do str :: stream.ReadStr()
				if(str =& null)
					break a
				end if
				switch(str)
				case("v")
					do me.v  :~ [(#cVector).Init(stream.ReadFloat(), stream.ReadFloat(), stream.ReadFloat())]
				case("uv")
					do me.uv :~ [(#cVector2D).Init(stream.ReadFloat(), stream.ReadFloat())]
				case("vn")
					do me.vn :~ [(#cVector).Init(stream.ReadFloat(), stream.ReadFloat(), stream.ReadFloat())]
				case("f")
					for i(0, n - 1)
						do str :: stream.ReadStr()
						if(countSlash(str) <> 2)
							do Dbg@Log("Error: f format error. It must be \"f v/uv/vn v/uv/vn v/uv/vn\". (f-id " ~ me.f.Len().ToStr() ~ ")")
							continue a
						end if
						func countSlash(str: []char): int
							var ret: int
							foreach c(str)
								if(c = '/')
									do ret :+ 1
								end if
							end foreach
							return ret
						end func
						for j(0, str.Len() - 1)
							if(str[j] = '/')
								if(p1 = 0)
									do p1 :: j
									continue j
								else
									do p2 :: j
									break j
								end if
							end if
						end for
						var s1: []char :: str.Sub(0, p1)
						var s2: []char :: (p2 - p1 <> 1) ?(str.Sub(p1 + 1, p2 - p1 - 1), "0")
						var s3: []char :: (str.Len() - p2 <> 1) ?(str.Sub(p2 + 1, str.Len() - p2 - 1), "0")
						do p1 :: 0
						do posIdSet[i].vId :: s1 $ int
						do posIdSet[i].uvId :: s2 $ int
						do posIdSet[i].vnId :: s3 $ int
					end for
					do me.f :~ [(#@CFacet).Init(posIdSet)]
				end switch
			end while
		catch()
			do Dbg@Log("Error: Unexpected error. Please tell me (@tatt61880) the info.")
		end try

		return me
	end func

	class cVector()
		var x: float
		var y: float
		var z: float
		func Init(x: float, y: float, z: float): cVector
			do me.x :: x
			do me.y :: y
			do me.z :: z
			return me
		end func
		-+func Cmp(t: cVector): int
			if(me.x = t.x & me.y = t.y & me.z = t.z)
				return 0
			elif(me.x > t.x | (me.x = t.x & (me.y > t.y | me.y = t.y & me.z > t.z)))
				return 1
			else
				return -1
			end if
		end func
	end class
	class cVector2D()
		var x: float
		var y: float
		func Init(x: float, y: float): cVector2D
			do me.x :: x
			do me.y :: y
			return me
		end func
		-+func Cmp(t: cVector2D): int
			if(me.x = t.x & me.y = t.y)
				return 0
			elif(me.x > t.x | (me.x = t.x & me.y > t.y))
				return 1
			else
				return -1
			end if
		end func
	end class

	func ToKnobj(path: []char)
		var bin: []byte8 :: #[0]byte8
		do bin :~ 0 .ToBins()
		do bin :~ 1 .ToBins()
		do bin :~ me.f.Len().ToBins()
		var fId: int :: 1
		foreach f(me.f)
			for i(0, 2) {Check uv}
				if(me.uv[f.positions[i].uvId] = me.uv[f.positions[(i + 1) % 3].uvId])
					do Dbg@Log("[Obj.kn] Error: uv[" ~ f.positions[i].uvId.ToStr() ~ "] = uv[" ~ f.positions[(i + 1) % 3].uvId.ToStr() ~ "]")
					return
				end if
			end for
			for i(2, 0, -1)
				if(me.vn[f.positions[i].vnId] = (#cVector).Init(0.0, 0.0, 0.0)) {Check nv <> [0.0, 0.0, 0.0]}
					do Dbg@Log("[Obj.kn] Error: vn[" ~ f.positions[i].vnId.ToStr() ~ "] = [0,0, 0.0, 0.0]")
					return
				end if

				if(f.positions[i].vId < me.v.Len())
					do bin :~ (me.v[f.positions[i].vId].x).ToBins()
					do bin :~ (me.v[f.positions[i].vId].y).ToBins()
					do bin :~ (me.v[f.positions[i].vId].z).ToBins()
				else
					do Dbg@Log("Error: Invalid  v-id " ~ f.positions[i].vId.ToStr()  ~ " (f-id " ~ fId.ToStr() ~")")
				end if
				if(f.positions[i].uvId < me.uv.Len())
					do bin :~ (me.uv[f.positions[i].uvId].x).ToBins()
					do bin :~ (me.uv[f.positions[i].uvId].y).ToBins()
				else
					do Dbg@Log("Error: Invalid uv-id " ~ f.positions[i].uvId.ToStr() ~ " (f-id " ~ fId.ToStr() ~")")
				end if
				if(f.positions[i].vnId < me.vn.Len())
					do bin :~ (me.vn[f.positions[i].vnId].x).ToBins()
					do bin :~ (me.vn[f.positions[i].vnId].y).ToBins()
					do bin :~ (me.vn[f.positions[i].vnId].z).ToBins()
				else
					do Dbg@Log("Error: Invalid vn-id " ~ f.positions[i].vnId.ToStr() ~ " (f-id " ~ fId.ToStr() ~")")
				end if
			end for
			do fId :+ 1
		end foreach
		do Dbg@Log("# of triangles: " ~ (fId - 1).ToStr())
		do File@WriteFile(path, bin)
	end func
end class

-class CFacet()
	var positions: []@CPosIdSet
	func Init(ps: []@CPosIdSet): @CFacet
		do me.positions :: ##ps
		return me
	end func
end class

-class CPosIdSet()
	var vId: int
	var uvId: int
	var vnId: int
	func Init(vId: int, uvId: int, vnId: int): @CPosIdSet
		do me.vId :: vId
		do me.uvId :: uvId
		do me.vnId :: vnId
		return me
	end func
end class
